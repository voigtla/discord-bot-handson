# 第7回：エラー処理とフォールバック  
〜 Botが壊れたときに「変なことを言わない」ために 〜

この回は、**新しい機能を増やしません**。

その代わりに、

> 「何かが失敗したとき、  
> Botがどう振る舞うか」

を決めます。

---

## まず最初に（重要）

この回を終えたあと、Botはこうなります。

- Gemini API が止まっても Bot は落ちない
- DB が一時的に壊れても Bot は黙らない
- ユーザーにエラー内容を見せない
- 判断・助言・評価をしないまま安全に終わる

逆に言うと、  
**これをやらないと、実運用では必ず事故ります。**

---

## 🎯 この回のゴール

今日のゴールはたった1つです。

> **「失敗したら、必ず安全な固定文で終わる」Botにする**

---

## この回でやらないこと

あらかじめ言っておきます。

この回では、次のことは **一切やりません**。

- エラー内容を表示する  
- 原因をユーザーに説明する  
- 自動で再試行する  
- ログを通知する  

理由は単純で、  
**メンタル系サーバーでは、それ自体が負荷になるから**です。

---

## 今回の考え方（超重要）

Botの処理は、こう流れます。

```

うまくいく
↓
失敗する
↓
「いまは処理できませんでした」
↓
終了

```

- 余計なことを言わない  
- 取り繕わない  
- 励まさない  

**「安全側に倒す」** だけ。

---

## 今回触るファイル

第7回で触るのは、次の4つだけです。

```

source/
├─ index.js        ← reply の仕方を少し変える
├─ safeReply.js    ← ★ 新しく追加
├─ aiFormatter.js  ← try/catch を消す
└─ responses.js   ← フォールバック文言を追加

````

※ `db.js` は触りません。

---

## ① safeReply.js を追加する

まず、新しいファイルを作ります。

**`source/safeReply.js`**

このファイルの役割は1つだけ。

> **どんな失敗が起きても、  
> ユーザーには安全な文章だけを返す**

（コードは配布ソースをそのまま使ってください）

---

## ② aiFormatter.js を「失敗したら投げる」ようにする

ここでやることは逆です。

- エラーを捕まえない
- 握りつぶさない
- そのまま throw する

**なぜ？**

→ エラー処理は  
`safeReply` に全部集めたいから。

---

## ③ index.js の reply を包む

ここが一番大事です。

### 変更前（第6回まで）

```js
await interaction.reply(text);
````

### 変更後（第7回）

```js
await safeReply(interaction, async () => {
  return await formatText(text);
});
```

意味はこれだけです。

> 「失敗したら、自分で処理せず safeReply に任せる」

---

## ④ responses.js にフォールバック文言を足す

何かが壊れたとき、
**Botが必ず言う文章**を決めます。

例：

```js
fallback: "いまは処理できませんでした。時間をおいて、また試してください。",
```

* 判断しない
* 理由を説明しない
* 感情を煽らない

---

## 動作確認のしかた（重要）

ちゃんとできたか、必ず確認します。

### テスト手順

1. Bot を起動する
2. `/hello` や `/count` を実行（正常）
3. `.env` の `GEMINI_API_KEY` を一時的に消す
4. もう一度コマンドを実行

### 正解の挙動

* Bot が落ちない
* 固定のフォールバック文言が返る
* エラー詳細は表示されない

---

## この回で得られるもの

この回を終えると、

* AIを使っても怖くなくなる
* 「失敗前提」の設計ができるようになる
* 実運用に耐える Bot になる

---

## 次回（第8回）

次はコードをほとんど書きません。

第8回では、

* やってはいけない実装
* 善意で事故るパターン
* ルールをコードに戻す考え方

を扱います。

**「作れる」と「やっていい」は違う**
を、はっきり分ける回です。
